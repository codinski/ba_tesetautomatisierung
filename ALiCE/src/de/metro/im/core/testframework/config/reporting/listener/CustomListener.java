package de.metro.im.core.testframework.config.reporting.listener;

import java.util.List;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.testng.ITestContext;
import org.testng.ITestListener;
import org.testng.ITestResult;

import de.metro.im.core.testframework.config.reporting.ReportingUtility;
import de.metro.im.core.testframework.tests.TestDataProvider;
/**
 * This class handles the whole reporting. It implements the ITestListener to generate <br>
 * a reporting in real time. Reports by eMail though are sent after the testSuite is finished. <br>
 * The reason for this is that I am trying to send the HTML reports generated by TestNG which <br> 
 * are physically written after the whole test. If you want to inject eMail-Reports in real time <br> 
 * you have to either forgo the auto-generated test and send simple message respectively the <br> 
 * occuring error or you can try to force TestNG to dump the current information <br> 
 * prematurely to the disk an THEN send the HTML report. 
 * 
 * @author christoph.zabinski
 *
 */
public class CustomListener implements ITestListener {
	private static Logger log = LogManager.getLogger();
	
	@Override
	public void onTestStart(ITestResult result) {
		log.info(">>RUNNING: " + ListenerHelper.getCurrentMethodName(result));
	}

	@Override
	public void onTestSuccess(ITestResult result) {
		log.info("++SUCCESS: " + ListenerHelper.getCurrentMethodName(result));
		
	}
	
	@Override
	public void onTestFailure(ITestResult result) {
		String failedMethodName = ListenerHelper.getCurrentMethodName(result);
		String failedTestName = ListenerHelper.getCurrentTestName(result);
		String failReason = ListenerHelper.getCurrentFailureMessage(result);
		log.error("--FAILURE: " + failedMethodName + " in " + failedTestName + " : " + failReason);
		result.getThrowable().printStackTrace();
		ReportingUtility.captureScreenshot(failedTestName + "_" + failedMethodName); 
	}

	@Override
	public void onTestSkipped(ITestResult result) {
		log.info("::SKIPPING: " + ListenerHelper.getCurrentMethodName(result));
	}

	@Override
	public void onTestFailedButWithinSuccessPercentage(ITestResult result) {
	}

	@Override
	public void onStart(ITestContext context) {
		log.info("\n\nCurrent test: " + context.getCurrentXmlTest().getName());
	}

	//will be run after EACH test not after suit. executes after the @AfterTest method
	@Override
	public void onFinish(ITestContext context) {	
		log.info("==FINISHED: " + ListenerHelper.getCurrentTestName(context));
		
		
		if(ListenerHelper.hasFailedTests(context)){
			ReportingUtility.reportToDB(context, "", ITestResult.FAILURE); //TODO zum testen auskommentiert
			ReportingUtility.sendMailReportWithFailures(context);

		} else {
			ReportingUtility.reportToDB(context, "", ITestResult.SUCCESS);  //TODO zum testen auskommentiert
		}
	}

	//FIXME funktioniert noch nicht - evtl erscheint das nur im html report. dann ist die info sogar gut. 
	@SuppressWarnings("unused")
	private void removeSensitiveParameters(ITestContext context) {
		Set<ITestResult> failedTests = ListenerHelper.getAllFailedTestsResults(context);
		for (ITestResult result : failedTests) {
			for (Object param : result.getParameters()){
				List<String> data = TestDataProvider.getLoginInfo(context);
				if(data.contains(param)) {
					System.out.println(param);
					param = "**********";
					System.out.println(param);
				}
			}
		}
	}

	
}
